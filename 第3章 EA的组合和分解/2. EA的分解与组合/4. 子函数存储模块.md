# 4. 子函数存储模块

在本例中,在子函数存储模块中编写了4个子函数:

- `canPlaceBuyOrder()`: 判断是否可以下买单
- `placeBuyOrder()`: 执行买单操作
- `closeBuyOrder()`: 关闭买单操作
- `canPlaceSellOrder()`: 判断是否可以下卖单
- `placeSellOrder()`: 执行卖单操作
- `closeSellOrder()`: 关闭卖单操作

```mq4
//+------------------------------------------------------------------+
// 本函数用于判断当前条件是否符合下买单的条件
// 下买单的条件:
// Condition1: 没有订单
// Condition2: 今天的开盘价与昨天的收盘价之间的差价大于20个点
bool canPlaceBuyOrder() {
   // 若此时持有订单 则不符合下买单的条件
   if (OrdersTotal() != 0) {
      return false;
   }

   // 计算今天的开盘价和昨天的收盘价之间的价差是否大于20个点
   // 今天的开盘价
   double todayOpen = iOpen(currencyPair, PERIOD_D1, 0);
   
   // 昨天的收盘价
   double yesterdayClose = iClose(currencyPair, PERIOD_D1, 1);
   
   // 今天的开盘价 与 昨天的收盘价 之间的差值
   double diffTodayOpenAndYesterdayClose = todayOpen - yesterdayClose;
   
   // 该差值是否大于20个点
   bool diffIsGreaterThan20 = diffTodayOpenAndYesterdayClose > 20 * Point;
   
   // TODO: 由于编写代码时为周六 外汇交易市场都不开盘 拿BTC/USD做的测试 开盘价和收盘价是一样的
   // TODO: 周一再拿EUR/JPY测试一次
   // Print("今天的开盘价为: ", todayOpen);
   // Print("昨天的收盘价为: ", yesterdayClose);
   // Print("今天的开盘价与昨天的收盘价之间的差值为: ", diffTodayOpenAndYesterdayClose);
   // Print("差值是否大于20个点: ", diffIsGreaterThan20);
   return diffIsGreaterThan20;
}

// 本函数用于下1个买单
void placeBuyOrder() {
   // 将下单量的数值转换为指定精度
   orderVolume = NormalizeDouble(orderVolume, 2);
   
   // 限制下单量的数值必须大于系统默认该货币对的最小下单量
   if (orderVolume < MarketInfo(currencyPair, MODE_MINLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MINLOT);
   }
   
   // 限制下单量的数值不得大于预设的最大下单量
   if (orderVolume > maxOrderVolume) {
      orderVolume = maxOrderVolume;
   }
   
   // 限制下单量的数值必须小于系统默认该货币对的最大下单量
   if (orderVolume > MarketInfo(currencyPair, MODE_MAXLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MAXLOT);
   }
   
   // 计算订单的止盈价格
   if (stopProfitPoint == 0) {
      stopProfitPrice = 0;
   }
   
   if (stopProfitPoint > 0) {
      // Tips: 这里之所以使用 `ASK + 距离` 作为买单的止盈价,是因为买单止盈价的定义为: 止盈价 = 开仓价 + 距离
      // Tips: 而一个买单的开仓价是下买单时的ASK价格 所以这里使用 `ASK + 距离`定义止盈价 后续的止损价也是同理的
      // Tips: 很明显,买单是做多,所以价格涨了是止盈,价格跌了是止损
      stopProfitPrice = (MarketInfo(currencyPair, MODE_ASK)) + (stopProfitPoint * MarketInfo(currencyPair, MODE_POINT));
   }
   
   // 计算订单的止损价格
   if (stopLossPoint == 0) {
      stopLossPrice = 0;
   }
   
   if (stopLossPoint > 0) {
      // Tips: 买单止损价 = ASK - 距离
      stopLossPrice = (MarketInfo(currencyPair, MODE_ASK)) - (stopLossPoint * MarketInfo(currencyPair, MODE_POINT));
   }
   
   // 完成下买单动作
   // Violet: 颜色
   ticket = OrderSend(currencyPair, OP_BUY, orderVolume, MarketInfo(currencyPair, MODE_ASK), slippage, stopLossPrice, stopProfitPrice, "下买单", MAGIC, 0, Violet);
   
   if (!alertFlag) {
      return;
   }
   
   if (ticket < 0) {
      Alert("下买单失败!", GetLastError());
      return;
   }
   
   Alert("下买单成功!");
}

// 本函数用于判断当前条件是否符合下卖单的条件
// 下买单的条件:
// Condition1: 当前持有1个订单
// Condition2: 昨天的开盘价与昨天的收盘价之间的差价大于30个点
bool canPlaceSellOrder() {
   // 若此时持有的订单数不为1 则不符合下买单的条件
   if (OrdersTotal() != 1) {
      return false;
   }
   
   // 计算昨天的开盘价与昨天的收盘价之间的差价是否大于30个点
   // 昨天的开盘价
   double yesterdayOpen = iOpen(currencyPair, PERIOD_D1, 1);
   
   // 昨天的收盘价
   double yesterdayClose = iClose(currencyPair, PERIOD_D1, 1);
   
   // 昨天的开盘价 与 昨天的收盘价 之间的差值
   double diffYesterdayOpenAndYesterdayClose = yesterdayOpen - yesterdayClose;
   
   // 该差值是否大于30个点
   bool diffIsGreaterThan30 = diffYesterdayOpenAndYesterdayClose > 30 * Point;
   return diffIsGreaterThan30;
}

// 本函数用于下1个卖单
void placeSellOrder() {
   // 将下单量的数值转换为指定精度
   orderVolume = NormalizeDouble(orderVolume, 2);
   
   // 限制下单量的数值必须大于系统默认该货币对的最小下单量
   if (orderVolume < MarketInfo(currencyPair, MODE_MINLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MINLOT);
   }
   
   // 限制下单量的数值不得大于预设的最大下单量
   if (orderVolume > maxOrderVolume) {
      orderVolume = maxOrderVolume;
   }
   
   // 限制下单量的数值必须小于系统默认该货币对的最大下单量
   if (orderVolume > MarketInfo(currencyPair, MODE_MAXLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MAXLOT);
   }
   
   // 计算订单的止盈价格
   if (stopProfitPoint == 0) {
      stopProfitPrice = 0;
   }
   
   if (stopProfitPoint > 0) {
      // Tips: 卖单是做空 所以止盈价格为 `卖出价 - 距离`
      // Tips: 同理 止损价格为: `卖出价 + 距离`
      stopProfitPrice = MarketInfo(currencyPair, MODE_BID) - (stopProfitPoint * MarketInfo(currencyPair, MODE_POINT));
   }
   
   // 计算订单的止损价格
   if (stopLossPoint == 0) {
      stopLossPrice = 0;
   }
   
   if (stopLossPoint > 0) {
      stopLossPrice = MarketInfo(currencyPair, MODE_BID) + (stopProfitPoint * MarketInfo(currencyPair, MODE_POINT));
   }
   
   // 完成下卖单动作
   ticket = OrderSend(currencyPair, OP_SELL, orderVolume, MarketInfo(currencyPair, MODE_BID), slippage, stopLossPrice, stopProfitPrice, "下卖单", MAGIC, 0, YellowGreen);
   
   if (!alertFlag) {
      return;
   }
   
   if (ticket < 0) {
      Alert("下卖单失败!", GetLastError());
      return;
   }
   
   Alert("下卖单成功!");
}

// 本函数用于关闭买单
void closeBuyOrder() {
   // 关闭买单时的卖价
   double orderBid;
   
   // 被选中的订单的交易手数
   double orderLot;
   
   // 被选中的订单的类型 (就是使用OrderSend()函数创建订单时的第2个参数)
   int orderType;
   
   // 被选中的订单的编号
   int orderTicket = 0;
   
   // 用于遍历订单的索引号
   int orderIndex;
   
   // 标识订单关闭是否成功的标记位
   bool closeResult = false;
   
   // 遍历所有订单
   for( orderIndex = OrdersTotal() - 1; orderIndex >= 0; orderIndex-- ) {
      // OrderSelect()函数用于选定1个订单 选定后可以使用OrderTicket()/OrderType()/OrderLots()等函数
      // 读取这个被选定的订单的属性
      // SELECT_BY_POS: 表示按位置选择
      bool selectResult = OrderSelect(orderIndex, SELECT_BY_POS);
      if (!selectResult) {
         continue;
      }
      
      // 意义不明
      if (OrdersTotal() <= 0) {
         continue;
      }
      
      // 被选定的订单的外汇品种不是当前EA中记录的货币对
      // 则证明该订单不是当前EA要操作的订单
      if (OrderSymbol() != currencyPair) {
         continue;
      }
      
      // 被选定的订单的魔术号不是当前EA中记录的魔术号
      // 则证明该订单并非由当前EA创建 不应该由当前EA操作
      // (目前没有其他EA 所以这个逻辑是正确的 等到自己编写EA时 可能会出现当前EA要关闭的订单是由其他EA创建的情况)
      if (OrderMagicNumber() != MAGIC) {
         continue;
      }
      
      // 获取订单卖价
      orderBid = MarketInfo(currencyPair, MODE_BID);
      
      // 获取订单编号
      orderTicket = OrderTicket();
      
      // 获取订单交易手数
      orderLot = OrderLots();
      
      // 获取订单类型
      orderType = OrderType();
      
      // 若订单为买单 则将该订单关闭(即: 卖出平仓)
      if(orderType == OP_BUY) {
         closeResult = OrderClose(orderTicket, orderLot, orderBid, slippage, Yellow);
      }
      
      if (alertFlag) {
         Alert("关闭买单结果为: ", closeResult);
      }
      
      break;
   }
}

// 本函数用于关闭卖单
void closeSellOrder() {
      // 关闭卖单时的买价
   double orderAsk;
   
   // 被选中的订单的交易手数
   double orderLot;
   
   // 被选中的订单的类型 (就是使用OrderSend()函数创建订单时的第2个参数)
   int orderType;
   
   // 被选中的订单的编号
   int orderTicket = 0;
   
   // 用于遍历订单的索引号
   int orderIndex;
   
   // 标识订单关闭是否成功的标记位
   bool closeResult = false;
   
   for( orderIndex = OrdersTotal() - 1; orderIndex >= 0; orderIndex-- ) {
      bool selectResult = OrderSelect(orderIndex, SELECT_BY_POS);
      if (!selectResult) {
         continue;
      }
      
      if (OrdersTotal() <= 0) {
         continue;
      }
      
      if (OrderSymbol() != currencyPair) {
         continue;
      }
      
      if (OrderMagicNumber() != MAGIC) {
         continue;
      }
      
      // 获取订单买价
      orderAsk = MarketInfo(currencyPair, MODE_ASK);
      
      // 获取订单编号
      orderTicket = OrderTicket();
      
      // 获取订单交易手数
      orderLot = OrderLots();
      
      // 获取订单类型
      orderType = OrderType();
      
      // 若订单为卖单 则将该订单关闭(即: 买入平仓)
      if(orderType == OP_SELL) {
         closeResult = OrderClose(orderTicket, orderLot, orderAsk, slippage, Red);
      }
      
      if (alertFlag) {
         Alert("关闭卖单结果为: ", closeResult);
      }
      
      break;
   }
}
```
