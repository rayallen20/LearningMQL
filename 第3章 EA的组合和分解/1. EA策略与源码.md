# 1. EA策略与源码

此处以一个EA策略举例,该示例的核心策略为:

- 若系统中没有订单,且今天的开盘价比昨天的收盘价高20个点
  - 则下一个买单,买单要求:
    - 止损200点
    - 止盈200点
    - 下单量为0.02手
- 若系统中已有1个订单,且昨天的开盘价比收盘价高30个点
  - 则下一个卖单,卖单要求:
    - 不设置止损及止盈
    - 下单量为0.04手
- 若账户盈利大于3美元
  - 则将买单和卖单平仓

上述过程一直循环执行.

EA的部分代码(尚未全部实现)如下:

```mq4
//+------------------------------------------------------------------+
//|                                                         示例EA.mq4 |
//|                                  Copyright 2025, MetaQuotes Ltd. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, MetaQuotes Ltd."
#property link      "https://www.mql5.com"
#property version   "1.00"
#property strict

// orderVolume 下单量
double orderVolume;

// currencyPair 货币对
string currencyPair;

// maxOrderVolume 最大下单量
double maxOrderVolume = 100;

// stopLossPoint 止损点数
// stopLossPrice 止损价格
double stopLossPoint, stopLossPrice;

// stopProfitPoint 止盈点数
// stopProfitPrice 止盈价格
double stopProfitPoint, stopProfitPrice;

// MAGIC 魔术号,和EA是1对1关系.本质是一个用户自定义的订单标识.用于在同一个账户中,标识不同EA下的订单
int MAGIC = 100;

// ticket 表示订单的唯一标识符(ID)
int ticket;

// slippage 滑点 即: 下单时预期的成交价格 与 最终实际成交价格 之间的差值
// 滑点是有正负的 
// 正滑点表示实际成交价格比我预期的好(例如我期望1.1000价格买入,但实际成交价格为1.0008,即产生了2个正滑点)
// 负滑点表示实际成交价格比我预期的差(例如我期望1.1000价格买入,但实际成交价格为1.0015,即产生了15个负滑点)
int slippage;

// alertFlag 标识是否开启警告的标记位
bool alertFlag = false;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- create timer
   EventSetTimer(60);
   
//---
   return(INIT_SUCCEEDED);
  }
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//--- destroy timer
   EventKillTimer();
   
  }
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
//---
   // 指定交易的货币对为 EA加载时的货币对
   currencyPair = Symbol();
   
   // 判断是否符合下买单条件
   bool canPlaceBuyOrder = canPlaceBuyOrder();
   if(canPlaceBuyOrder) {
      // 指定下单量的大小
      orderVolume = 0.02;
      
      // 指定止损点数
      stopLossPoint = 200;
      
      // 指定止盈点数
      stopProfitPoint = 200;
      
      // 完成下买单动作
      placeBuyOrder();
   }
   
   // 判断是否符合下卖单条件
   bool canPlaceSellOrder = canPlaceSellOrder();
   if (canPlaceSellOrder) {
      // 指定下单量的大小
      orderVolume = 0.04;
      
      // 完成下卖单动作
      placeSellOrder();
   }
  }
//+------------------------------------------------------------------+
//| Timer function                                                   |
//+------------------------------------------------------------------+
void OnTimer()
  {
//---
   
  }
//+------------------------------------------------------------------+
// 本函数用于判断当前条件是否符合下买单的条件
// 下买单的条件:
// Condition1: 没有订单
// Condition2: 今天的开盘价与昨天的收盘价之间的差价大于20个点
bool canPlaceBuyOrder() {
   // 若此时持有订单 则不符合下买单的条件
   if (OrdersTotal() != 0) {
      return false;
   }

   // 计算今天的开盘价和昨天的收盘价之间的价差是否大于20个点
   // 今天的开盘价
   double todayOpen = iOpen(currencyPair, PERIOD_D1, 0);
   
   // 昨天的收盘价
   double yesterdayClose = iClose(currencyPair, PERIOD_D1, 1);
   
   // 今天的开盘价 与 昨天的收盘价 之间的差值
   double diffTodayOpenAndYesterdayClose = todayOpen - yesterdayClose;
   
   // 该差值是否大于20个点
   bool diffIsGreaterThan20 = diffTodayOpenAndYesterdayClose > 20 * Point;
   
   // TODO: 由于编写代码时为周六 外汇交易市场都不开盘 拿BTC/USD做的测试 开盘价和收盘价是一样的
   // TODO: 周一再拿EUR/JPY测试一次
   // Print("今天的开盘价为: ", todayOpen);
   // Print("昨天的收盘价为: ", yesterdayClose);
   // Print("今天的开盘价与昨天的收盘价之间的差值为: ", diffTodayOpenAndYesterdayClose);
   // Print("差值是否大于20个点: ", diffIsGreaterThan20);
   return diffIsGreaterThan20;
}

// 本函数用于下1个买单
void placeBuyOrder() {
   // 将下单量的数值转换为指定精度
   orderVolume = NormalizeDouble(orderVolume, 2);
   
   // 限制下单量的数值必须大于系统默认该货币对的最小下单量
   if (orderVolume < MarketInfo(currencyPair, MODE_MINLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MINLOT);
   }
   
   // 限制下单量的数值不得大于预设的最大下单量
   if (orderVolume > maxOrderVolume) {
      orderVolume = maxOrderVolume;
   }
   
   // 限制下单量的数值必须小于系统默认该货币对的最大下单量
   if (orderVolume > MarketInfo(currencyPair, MODE_MAXLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MAXLOT);
   }
   
   // 计算订单的止盈价格
   if (stopProfitPoint == 0) {
      stopProfitPrice = 0;
   }
   
   if (stopProfitPoint > 0) {
      // Tips: 这里之所以使用 `ASK + 距离` 作为买单的止盈价,是因为买单止盈价的定义为: 止盈价 = 开仓价 + 距离
      // Tips: 而一个买单的开仓价是下买单时的ASK价格 所以这里使用 `ASK + 距离`定义止盈价 后续的止损价也是同理的
      // Tips: 很明显,买单是做多,所以价格涨了是止盈,价格跌了是止损
      stopProfitPrice = (MarketInfo(currencyPair, MODE_ASK)) + (stopProfitPoint * MarketInfo(currencyPair, MODE_POINT));
   }
   
   // 计算订单的止损价格
   if (stopLossPoint == 0) {
      stopLossPrice = 0;
   }
   
   if (stopLossPoint > 0) {
      // Tips: 买单止损价 = ASK - 距离
      stopLossPrice = (MarketInfo(currencyPair, MODE_ASK)) - (stopLossPoint * MarketInfo(currencyPair, MODE_POINT));
   }
   
   // 完成下买单动作
   // Violet: 颜色
   ticket = OrderSend(currencyPair, OP_BUY, orderVolume, MarketInfo(currencyPair, MODE_ASK), slippage, stopLossPrice, stopProfitPrice, "下买单", MAGIC, 0, Violet);
   
   if (!alertFlag) {
      return;
   }
   
   if (ticket < 0) {
      Alert("下买单失败!", GetLastError());
      return;
   }
   
   Alert("下买单成功!");
}

// 本函数用于判断当前条件是否符合下卖单的条件
// 下买单的条件:
// Condition1: 当前持有1个订单
// Condition2: 昨天的开盘价与昨天的收盘价之间的差价大于30个点
bool canPlaceSellOrder() {
   // 若此时持有的订单数不为1 则不符合下买单的条件
   if (OrdersTotal() != 1) {
      return false;
   }
   
   // 计算昨天的开盘价与昨天的收盘价之间的差价是否大于30个点
   // 昨天的开盘价
   double yesterdayOpen = iOpen(currencyPair, PERIOD_D1, 1);
   
   // 昨天的收盘价
   double yesterdayClose = iClose(currencyPair, PERIOD_D1, 1);
   
   // 昨天的开盘价 与 昨天的收盘价 之间的差值
   double diffYesterdayOpenAndYesterdayClose = yesterdayOpen - yesterdayClose;
   
   // 该差值是否大于30个点
   bool diffIsGreaterThan30 = diffYesterdayOpenAndYesterdayClose > 30 * Point;
   return diffIsGreaterThan30;
}

// 本函数用于下1个卖单
void placeSellOrder() {
   // 将下单量的数值转换为指定精度
   orderVolume = NormalizeDouble(orderVolume, 2);
   
   // 限制下单量的数值必须大于系统默认该货币对的最小下单量
   if (orderVolume < MarketInfo(currencyPair, MODE_MINLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MINLOT);
   }
   
   // 限制下单量的数值不得大于预设的最大下单量
   if (orderVolume > maxOrderVolume) {
      orderVolume = maxOrderVolume;
   }
   
   // 限制下单量的数值必须小于系统默认该货币对的最大下单量
   if (orderVolume > MarketInfo(currencyPair, MODE_MAXLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MAXLOT);
   }
   
   // 计算订单的止盈价格
   if (stopProfitPoint == 0) {
      stopProfitPrice = 0;
   }
   
   if (stopProfitPoint > 0) {
      // Tips: 卖单是做空 所以止盈价格为 `卖出价 - 距离`
      // Tips: 同理 止损价格为: `卖出价 + 距离`
      stopProfitPrice = MarketInfo(currencyPair, MODE_BID) - (stopProfitPoint * MarketInfo(currencyPair, MODE_POINT));
   }
   
   // 计算订单的止损价格
   if (stopLossPoint == 0) {
      stopLossPrice = 0;
   }
   
   if (stopLossPoint > 0) {
      stopLossPrice = MarketInfo(currencyPair, MODE_BID) + (stopProfitPoint * MarketInfo(currencyPair, MODE_POINT));
   }
   
   // 完成下卖单动作
   ticket = OrderSend(currencyPair, OP_SELL, orderVolume, MarketInfo(currencyPair, MODE_BID), slippage, stopLossPrice, stopProfitPrice, "下卖单", MAGIC, 0, YellowGreen);
   
   if (!alertFlag) {
      return;
   }
   
   if (ticket < 0) {
      Alert("下卖单失败!", GetLastError());
      return;
   }
   
   Alert("下卖单成功!");
}
```

代码解释:

- `MAGIC`: 魔术号,和EA是1对1关系.本质是一个用户自定义的订单标识.用于在同一个账户中,标识不同EA下的订单
- `ticket`: 表示订单的唯一标识符(ID),类似于订单号的概念
- `slippage`: 滑点 即: 下单时预期的成交价格与最终实际成交价格之间的差值
  - 滑点是有正负的 
  - 正滑点表示实际成交价格比我预期的好(例如我期望1.1000价格买入,但实际成交价格为1.0008,即产生了2个正滑点)
  - 负滑点表示实际成交价格比我预期的差(例如我期望1.1000价格买入,但实际成交价格为1.0015,即产生了15个负滑点)
- 计算某2个价格之间的价差为多少个点位时,是需要拿差值和点位进行比较的,而不是直接和一个数字比较
- 下单之前,要将下单量转换成指定的精度,否则有可能会因为精度问题而被服务器拒单
- 止损价与止盈价
  - 对于买单而言,相当于是做多,所以价格涨了是止盈,价格跌了是止损
    - 买单止盈价 = 开仓价 + 距离
      - 距离 = 止盈点数 * 点值
    - 买单止损价 = 开仓价 - 距离
      - 距离 = 止损点数 * 点值
    - 由于买单的开仓价是下买单时的ASK价格(经纪商卖给我的价格),所以买单的止盈价和止损价分别为:
      - 买单止盈价 = ASK + 距离
      - 买单止损价 = ASK - 距离
  - 对于卖单而言,相当于是做空,所以价格跌了是止盈,价格涨了是止损
    - 卖单止盈价 = 开仓价 - 距离
      - 距离 = 止盈点数 * 点值
    - 卖单止损价 = 开仓价 + 距离
      - 距离 = 止损点数 * 点值
    - 由于卖单的开仓价是下卖单时的BID价格(我卖给经纪商时的价格),所以卖单的止盈价和止损价分别为:
      - 卖单止盈价 = BID - 距离
      - 卖单止损价 = BID + 距离
- `OrderSend()`函数的第10个参数: 表示到期时间,0表示订单永不过期.
  - 该参数仅当第2个参数的值为`OP_BUYLIMIT`/`OP_BUYSTOP`/`OP_SELLLIMIT`/`OP_SELLSTOP`时有效
  - 表示该订单在该参数指定的时间之前有效,超过该时间则该订单失效
  - 若第2个参数的值为`OP_BUY`/`OP_SELL`,则该参数无效,因为这2个值表示以市价成交
- "1手"的概念: `1手 = 100,000个基础货币单位`
  - `EUR/JPY`的1手 = 100,000欧元
  - `EUR/USD`的1手 = 100,000欧元
  - 二者都是要买入100,000欧元,只是卖出的货币类型不同
  - 我使用的这个交易软件,最小交易单位为0.01手,即1,000个基础货币单位
    - 如果是`EUR/JPY`,则表示最小交易单位为1,000欧元
