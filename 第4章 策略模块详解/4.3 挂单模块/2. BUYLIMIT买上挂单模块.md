# 2. `BUYLIMIT`买上挂单模块

- `BUYLIMIT`: 是指以**低于现价的价格挂单**的买进操作指令.可以认为`BUYLIMIT`是在一段上涨趋势中,找低点买入的操作

假设现在`EUR:USD = 1: 1.4321`,你觉得EUR的趋势仍然是向上的,但是价格会跌到`EUR:USD = 1: 1.4300`,然后继续上涨.
则可以在`EUR:USD = 1: 1.4300`处设置1个`BUYLIMIT`挂单,当价格从`EUR:USD = 1: 1.4321`回落到`EUR:USD = 1: 1.4300`时,
买单将会成交.若价格继续上涨,则会盈利.

```mq4
//+------------------------------------------------------------------+
//|                                                   BUYLIMIT挂单.mq4 |
//|                                  Copyright 2025, MetaQuotes Ltd. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, MetaQuotes Ltd."
#property link      "https://www.mql5.com"
#property version   "1.00"
#property strict

// orderVolume 下单量
double orderVolume;

// currencyPair 货币对
string currencyPair;

// maxOrderVolume 最大下单量
double maxOrderVolume = 100;

// stopProfitPoint 止盈点数
// stopProfitPrice 止盈价格
// baseStopProfitPrice 以市价下买单时的止盈价格
double stopProfitPoint, stopProfitPrice, baseStopProfitPrice;

// stopLossPoint 止损点数
// stopLossPrice 止损价格
// baseStopLossPrice 以市价下买单时的止损价格
double stopLossPoint, stopLossPrice, baseStopLossPrice;

// MAGIC 魔术号,和EA是1对1关系.本质是一个用户自定义的订单标识.用于在同一个账户中,标识不同EA下的订单
int MAGIC = 103;

// ticket 表示订单的唯一标识符(ID)
int ticket;

// slippage 滑点 即: 下单时预期的成交价格 与 最终实际成交价格 之间的差值
// 滑点是有正负的 
// 正滑点表示实际成交价格比我预期的好(例如我期望1.1000价格买入,但实际成交价格为1.0008,即产生了2个正滑点)
// 负滑点表示实际成交价格比我预期的差(例如我期望1.1000价格买入,但实际成交价格为1.1015,即产生了15个负滑点)
int slippage;

// alertFlag 标识是否开启警告的标记位
bool alertFlag = false;

// pendingOrderLineNumber 线条数量
// 线条: 当设置了1个BUYSTOP挂单时,系统会在设定的挂单价格位置画一条水平线.这条线就是挂单的触发价位.
// 所以这里说的"线条",实际上就是挂单位置.市场价格(K线)一旦触碰或超过这条线,挂单就会被执行,变成一张真实订单.
int pendingOrderLineNumber;

// 点数距离: 即相邻两个BUYLIMIT挂单之间的点数距离
int pointDistance;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- create timer
   EventSetTimer(10);
   
//---
   return(INIT_SUCCEEDED);
  }
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//--- destroy timer
   EventKillTimer();
   
  }
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
//---
   
  }
//+------------------------------------------------------------------+
//| Timer function                                                   |
//+------------------------------------------------------------------+
void OnTimer()
  {
//---
   orderVolume = 0.01;
   currencyPair = Symbol();
   pointDistance = 200;
   pendingOrderLineNumber = 3;
   stopLossPoint = 100;
   stopProfitPoint = 300;
   
   placeBuyBUYLIMITOrder();
  }
//+------------------------------------------------------------------+
// 本函数用于根据全局变量pendingOrderLineNumber的值
// 挂一组BUYLIMIT单
// BUYLIMIT单: 以低于现价的价格买入的订单.BUYLIMIT单的成交价格都是低于挂单时的市场价格的
// 按照定义上来讲 多个连续的BUYLIMIT单 只要定义的成交价是递减的(第N个BUYSTOP单成交价 = 第N-1个BUYSTOP单成交价 - 点数距离)即可
void placeBuyBUYLIMITOrder() {
   // 将下单量的数值转换为指定精度
   orderVolume = NormalizeDouble(orderVolume, 2);
   
   // 限制下单量的数值必须大于系统默认该货币对的最小下单量
   if (orderVolume < MarketInfo(currencyPair, MODE_MINLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MINLOT);
   }
   
   // 限制下单量的数值不得大于预设的最大下单量
   if (orderVolume > maxOrderVolume) {
      orderVolume = maxOrderVolume;
   }
   
   // 限制下单量的数值必须小于系统默认该货币对的最大下单量
   if (orderVolume > MarketInfo(currencyPair, MODE_MAXLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MAXLOT);
   }
   
   // 限制挂单之间的点数距离
   if (pointDistance <= 2) {
      return;
   }
   
   // 限制要挂的订单数量
   if (pendingOrderLineNumber <= 0) {
      return;
   }
   
   for(int pendingOrderLineIndex = 1; pendingOrderLineIndex <= pendingOrderLineNumber; pendingOrderLineIndex++) {
      // 计算挂单的止盈价格
      if (stopProfitPoint == 0) {
         baseStopProfitPrice = 0;
         stopProfitPrice = 0;
      }
      
      if (stopProfitPoint > 0) {
         baseStopProfitPrice = MarketInfo(currencyPair, MODE_ASK) + stopProfitPoint * MarketInfo(currencyPair, MODE_POINT);
         // 第N个BUYLIMIT买单的止盈价格为 以市价下买单时的止盈价格 - N * 止盈点数
         stopProfitPrice = baseStopProfitPrice - pendingOrderLineIndex * stopProfitPoint * MarketInfo(currencyPair, MODE_POINT);
      }
      
      // 计算挂单的止损价格
      if (stopLossPoint == 0) {
         baseStopLossPrice = 0;
         stopProfitPrice = 0;
      }
      
      if (stopLossPoint > 0) {
         baseStopLossPrice = MarketInfo(currencyPair, MODE_ASK) - stopLossPoint * MarketInfo(currencyPair, MODE_POINT);
         // 第N个BUYLIMIT买单的止损价格为 以市价下买单时的止损价格 - N * 止盈点数
         stopLossPrice = baseStopLossPrice - pendingOrderLineIndex * stopLossPoint * MarketInfo(currencyPair, MODE_POINT);
      }
      
      // 第N个BUYLIMIT买单的买入价格为 市价 - N * 点数距离
      double placePrice = MarketInfo(currencyPair, MODE_ASK) - pendingOrderLineIndex * pointDistance * MarketInfo(currencyPair, MODE_POINT);
      
      /*
      Print("这是BUYLIMIT的第 ", pendingOrderLineIndex, " 单");
      Print("ASK价格为: ", MarketInfo(currencyPair, MODE_ASK));
      Print("下单价格为: ", placePrice);
      Print("base止盈价(以市价成交的买单的止盈价): ", baseStopProfitPrice);
      Print("订单止盈价: ", stopProfitPrice);
      Print("base止损价(以市价成交的买单的止损价): ", baseStopLossPrice);
      Print("订单止损价: ", stopLossPrice);
      */
      
      ticket = OrderSend(currencyPair, OP_BUYLIMIT, orderVolume, placePrice, slippage, stopLossPrice, stopProfitPrice, "BUYSTOP", MAGIC, 0, Green);
      
      if (!alertFlag) {
         continue;
      }
      
      if (ticket < 0) {
         Alert("BUYLIMIT下买单失败: ", GetLastError());
         continue;
      }
      
      Alert("BUYLIMIT下买单成功");
   }
}
```

- `BUYLIMIT`挂单: 和`BUYSTOP`挂单相反,用于逢低买入.即:你预期价格在下跌过程中会遇到支撑位反弹,因此在**当前市场价格之下**设置一个买入挂单
  - 连续的多个`BUYLIMIT`挂单之间,似乎也是只要求挂单价格是递减的(第N个`BUYLIMIT`单挂单价格 = 第N-1个`BUYLIMIT`单挂单价格 - 点数距离)即可,而不要求止盈价和止损价是递减的
  - 也就是说,本demo中给出的计算止盈价和止损价的算法,其实并没有实际含义,只是单纯的算出来这2个价格,让后续调用`OrderSend()`函数时,有值可用而已

本例中的市价/下单价格/止盈价/止损价如下(测试时以`EURJPY`货币对为例):

| `BUYLIMIT`订单顺序 | 市价(`ASK`价格) |  下单价格   | base止盈价(以市价成交的买单的止盈价) |  订单止盈价  | base止损价(以市价成交的买单的止损价) |  订单止损价  |
|:--------------:|:-----------:|:-------:|:---------------------:|:-------:|:---------------------:|:-------:|
|       1        |   174.041   | 173.841 |        174.341        | 174.041 |        173.941        | 173.841 |
|       2        |   174.041   | 173.641 |        174.341        | 173.741 |        173.941        | 173.741 |
|       3        |   174.041   | 173.441 |        174.341        | 173.441 |        173.941        | 173.641 |
