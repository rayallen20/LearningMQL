# 1. `BUYSTOP`买上挂单模块

- `BUYSTOP`: 是指以**高于现价的价格挂单**的买进操作指令.可以认为`BUYSTOP`是一个追涨的行为(涨不到位则不买,涨到位了才买)

假设现在`EUR:USD = 1: 1.4321`,你认为只有EUR向上突破了`1.4400`,才能确定涨势,并进一步上涨.这种场景下,
就可以在就可以在1.4410价格处挂一张`BUYSTOP`的挂单,当`EUR:USD > 1: 1.4410`时,挂单才会成交,若价格继续上涨,则会盈利.

```mq4
//+------------------------------------------------------------------+
//|                                                    BUYSTOP挂单.mq4 |
//|                                  Copyright 2025, MetaQuotes Ltd. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, MetaQuotes Ltd."
#property link      "https://www.mql5.com"
#property version   "1.00"
#property strict

// orderVolume 下单量
double orderVolume;

// currencyPair 货币对
string currencyPair;

// maxOrderVolume 最大下单量
double maxOrderVolume = 100;

// stopProfitPoint 止盈点数
// stopProfitPrice 止盈价格
// baseStopProfitPrice 以市价下买单时的止盈价格
double stopProfitPoint, stopProfitPrice, baseStopProfitPrice;

// stopLossPoint 止损点数
// stopLossPrice 止损价格
// baseStopLossPrice 以市价下买单时的止损价格
double stopLossPoint, stopLossPrice, baseStopLossPrice;

// MAGIC 魔术号,和EA是1对1关系.本质是一个用户自定义的订单标识.用于在同一个账户中,标识不同EA下的订单
int MAGIC = 102;

// ticket 表示订单的唯一标识符(ID)
int ticket;

// slippage 滑点 即: 下单时预期的成交价格 与 最终实际成交价格 之间的差值
// 滑点是有正负的 
// 正滑点表示实际成交价格比我预期的好(例如我期望1.1000价格买入,但实际成交价格为1.0008,即产生了2个正滑点)
// 负滑点表示实际成交价格比我预期的差(例如我期望1.1000价格买入,但实际成交价格为1.1015,即产生了15个负滑点)
int slippage;

// alertFlag 标识是否开启警告的标记位
bool alertFlag = false;

// pendingOrderLineNumber 线条数量
// 线条: 当设置了1个BUYSTOP挂单时,系统会在设定的挂单价格位置画一条水平线.这条线就是挂单的触发价位.
// 所以这里说的"线条",实际上就是挂单位置.市场价格(K线)一旦触碰或超过这条线,挂单就会被执行,变成一张真实订单.
int pendingOrderLineNumber;

// 点数距离: 即相邻两个BUYSTOP挂单之间的点数距离
int pointDistance;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- create timer
   EventSetTimer(10);
   
//---
   return(INIT_SUCCEEDED);
  }
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//--- destroy timer
   EventKillTimer();
   
  }
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
//---
   
  }
//+------------------------------------------------------------------+
//| Timer function                                                   |
//+------------------------------------------------------------------+
void OnTimer()
  {
//---
   orderVolume = 0.01;
   currencyPair = Symbol();
   pointDistance = 200;
   pendingOrderLineNumber = 3;
   stopLossPoint = 100;
   stopProfitPoint = 200;
   
   placeBuyBUYSTOPOrder();
  }
//+------------------------------------------------------------------+
// 本函数用于根据全局变量pendingOrderLineNumber的值
// 挂一组BUYSTOP单
// BUYSTOP单: 用于追涨的订单.BUYSTOP单的成交价格都是高于挂单时的市场价格的
// 按照定义上来讲 多个连续的BUYSTOP单 只要定义的成交价是递增的(第N个BUYSTOP单成交价 = 第N-1个BUYSTOP单成交价 + 点数距离)即可
void placeBuyBUYSTOPOrder() {
   // 将下单量的数值转换为指定精度
   orderVolume = NormalizeDouble(orderVolume, 2);
   
   // 限制下单量的数值必须大于系统默认该货币对的最小下单量
   if (orderVolume < MarketInfo(currencyPair, MODE_MINLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MINLOT);
   }
   
   // 限制下单量的数值不得大于预设的最大下单量
   if (orderVolume > maxOrderVolume) {
      orderVolume = maxOrderVolume;
   }
   
   // 限制下单量的数值必须小于系统默认该货币对的最大下单量
   if (orderVolume > MarketInfo(currencyPair, MODE_MAXLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MAXLOT);
   }
   
   // 限制挂单之间的点数距离
   if (pointDistance <= 2) {
      return;
   }
   
   // 限制要挂的订单数量
   if (pendingOrderLineNumber <= 0) {
      return;
   }
   
   for(int pendingOrderLineIndex = 1; pendingOrderLineIndex <= pendingOrderLineNumber; pendingOrderLineIndex++) {
      // 计算挂单的止盈价格
      if (stopProfitPoint == 0) {
         stopProfitPrice = 0;
         baseStopProfitPrice = 0;
      }
      
      if (stopProfitPoint > 0) {
         baseStopProfitPrice = MarketInfo(currencyPair, MODE_ASK) + stopProfitPoint * MarketInfo(currencyPair, MODE_POINT);
         // 第N个BUYSTOP买单的止盈价格为 市价 + N * 止盈点数
         stopProfitPrice = baseStopProfitPrice + pendingOrderLineIndex * stopProfitPoint * MarketInfo(currencyPair, MODE_POINT);
      }
      
      // 计算挂单的止损价格
      if (stopLossPoint == 0) {
         stopProfitPrice = 0;
         baseStopLossPrice = 0;
      }
      
      if (stopLossPoint > 0) {
         baseStopLossPrice = MarketInfo(currencyPair, MODE_ASK) - stopLossPoint * MarketInfo(currencyPair, MODE_POINT);
         stopLossPrice = baseStopLossPrice + pendingOrderLineIndex * stopLossPoint * MarketInfo(currencyPair, MODE_POINT);
      }
      
      double placePrice = MarketInfo(currencyPair, MODE_ASK) + pendingOrderLineIndex * pointDistance * MarketInfo(currencyPair, MODE_POINT);
      
      /*
      Print("这是BUYSTOP的第 ", pendingOrderLineIndex, " 单");
      Print("ASK价格为: ", MarketInfo(currencyPair, MODE_ASK));
      Print("下单价格为: ", placePrice);
      Print("base止盈价(以市价成交的买单的止盈价): ", baseStopProfitPrice);
      Print("订单止盈价: ", stopProfitPrice);
      Print("base止损价(以市价成交的买单的止损价): ", baseStopLossPrice);
      Print("订单止损价: ", stopLossPrice);
      */
      ticket = OrderSend(currencyPair, OP_BUYSTOP, orderVolume, placePrice, slippage, stopLossPrice, stopProfitPrice, "BUYSTOP", MAGIC, 0, Green);
      
      if (!alertFlag) {
         continue;
      }
      
      if (ticket < 0) {
         Alert("BUYSTOP下买单失败: ", GetLastError());
         continue;
      }
      
      Alert("BUYSTOP下买单成功");
   }
}
```

- `BUYSTOP`挂单:用于追涨.即:你预期价格突破某个阻力位后,会继续上涨,因此在**当前市场价格之上**设置一个买入挂单
  - 例如:当前`EUR:USD = 1: 1.4321`,你认为只有EUR向上突破了`1.4400`,才能确定涨势,并进一步上涨
  - 该场景下,就可以在就可以在`1.4410`价格处挂一张`BUYSTOP`的挂单,当`EUR:USD > 1: 1.4410`时,挂单才会成交
  - 若价格继续上涨,则会盈利
  - 注意:`BUYSTOP`挂单并不是立刻成交的,而是要求你设置一个比当前市价(`ASK`价格)更高的价格,当市场价格涨到你设置的这个价格时,挂单才会被触发,并以你预设的价格成交
  - 从给出的demo中来看,多个连续的`BUYSTOP`挂单,只要定义的成交价是递增的(`第N个BUYSTOP单成交价 = 第N-1个BUYSTOP单成交价 + 点数距离`)即可
    - 但实际上我感觉似乎也可以让多个连续的`BUYSTOP`挂单的成交价不递增,只要每个`BUYSTOP`挂单的成交价都高于挂单时的市价即可
  - 对每个`BUYSTOP`挂单的止损和止盈价格,似乎不一定要求和`BUYSTOP`挂单的顺序(一种类似于索引的概念)有关,只要满足`止损价 < 挂单价 < 止盈价`即可
  - 因此这里我也只是按照代码的描述,把每个`BUYSTOP`挂单的止盈价和止损价按照代码的描述映射上了,因为我估计即使以后我要去写挂单,止盈价和止损价的算法和demo中描述的也不会一样
- 线条: 当你设置一个`BUYSTOP`挂单时,系统会在你设定的**挂单价格**位置画一条水平线.这条线就是**挂单的触发价位**
  - 该场景下的"线条",实际上就是**你的挂单位置**
  - 市场价格(K线)一旦触碰或超过这条线,挂单就会被执行,变成一张真实订单
- 点数距离: 即相邻2个`BUYSTOP`挂单之间的成交点数距离
  - 例如:当前`EUR:USD = 1.4321`,你设置了3个`BUYSTOP`挂单,点数距离为200点,则3个挂单的成交价分别为:
    - 第1个`BUYSTOP`挂单成交价 = 1.4321 + 200 * 0.0001 = 1.4521
    - 第2个`BUYSTOP`挂单成交价 = 1.4521 + 200 * 0.0001 = 1.4721
    - 第3个`BUYSTOP`挂单成交价 = 1.4721 + 200 * 0.0001 = 1.4921

本例中的市价/下单价格/止盈价/止损价如下(测试时以`EURJPY`货币对为例):

| `BUYSTOP`订单顺序 | 市价(`ASK`价格) |  下单价格   | base止盈价(以市价成交的买单的止盈价) |  订单止盈价  | base止损价(以市价成交的买单的止损价) |  订单止损价  |
|:-------------:|:-----------:|:-------:|:---------------------:|:-------:|:---------------------:|:-------:|
|       1       |   174.299   | 174.499 |        174.499        | 174.699 |        174.199        | 174.299 |
|       2       |   174.299   | 174.699 |        174.499        | 174.899 |        174.199        | 174.399 |
|       3       |   174.299   | 174.899 |        174.499        | 175.099 |        174.199        | 174.499 |
