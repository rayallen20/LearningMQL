# 2. 马丁策略的实现

- 入场条件: 在EA加载时,若没有卖单则下1张卖单,下单量为0.01,不设止损/止盈
- 加仓条件: 若亏损200点,则继续下1张卖单,下单量为上1张卖单下单量的2倍,不设止损/止盈
- 出场条件: 整体盈利2美元离场

```mq4
//+------------------------------------------------------------------+
//|                                                         马丁策略.mq4 |
//|                                  Copyright 2025, MetaQuotes Ltd. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, MetaQuotes Ltd."
#property link      "https://www.mql5.com"
#property version   "1.00"
#property strict

// 指定货币对 指定MAGIC下的 未平仓卖单的总数量
int s = 0;

// 指定货币对 指定MAGIC下的 所有未平仓卖单中 距当前最近的卖单的最近开盘价格
double LastPriceSell = 0;

// currencyPair 货币对
string currencyPair = Symbol();

// MAGIC 魔术号,和EA是1对1关系.本质是一个用户自定义的订单标识.用于在同一个账户中,标识不同EA下的订单
int MAGIC = 110;

// orderVolume 下单量
double orderVolume;

// 指定货币对 指定MAGIC下的 所有未平仓卖单中 距当前最近的卖单的下单量(交易手数)
double SLASTLOTS = 0;

// ticket 表示订单的唯一标识符(ID)
int ticket;

// stopLossPoint 止损点数
// stopLossPrice 止损价格
double stopLossPoint, stopLossPrice;

// stopProfitPoint 止盈点数
// stopProfitPrice 止盈价格
double stopProfitPoint, stopProfitPrice;

// slippage 滑点 即: 下单时预期的成交价格 与 最终实际成交价格 之间的差值
// 滑点是有正负的 
// 正滑点表示实际成交价格比我预期的好(例如我期望1.1000价格买入,但实际成交价格为1.0008,即产生了2个正滑点)
// 负滑点表示实际成交价格比我预期的差(例如我期望1.1000价格买入,但实际成交价格为1.1015,即产生了15个负滑点)
int slippage;

// maxOrderVolume 最大下单量
double maxOrderVolume = 100;

// alertFlag 标识是否开启警告的标记位
bool alertFlag = false;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- create timer
   EventSetTimer(60);
   
//---
   return(INIT_SUCCEEDED);
  }
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//--- destroy timer
   EventKillTimer();
   
  }
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
//---
   checkAccount();
   if (s == 0) {
      orderVolume = 0.01;
      placeSellOrder();
   }
   
   if (s != 0) {
      bool isDouble = MarketInfo(currencyPair, MODE_BID) - LastPriceSell > 200 * MarketInfo(currencyPair, MODE_POINT);
      if (isDouble) {
         orderVolume = 2 * SLASTLOTS;
         placeSellOrder();
      }
   }
   
   if (AccountProfit() > 2) {
      closeSellOrder();
   }
  }
//+------------------------------------------------------------------+
//| Timer function                                                   |
//+------------------------------------------------------------------+
void OnTimer()
  {
//---
   
  }
//+------------------------------------------------------------------+
// 本函数用于检查账户的各种情况
void checkAccount() {
   for (int cnt = 0; cnt < OrdersTotal(); cnt++) {
      bool selectResult = OrderSelect(cnt, SELECT_BY_POS, MODE_TRADES);
      if (!selectResult) {
         continue;
      }
      
      if (OrderSymbol() == currencyPair && OrderMagicNumber() == MAGIC) {
         if (OrderType() == OP_SELL) {
            // 指定货币对 指定MAGIC下的 未平仓卖单的总数量
            s++;
            // 指定货币对 指定MAGIC下的 所有未平仓卖单中 距当前最近的卖单的最近开盘价格
            LastPriceSell = OrderOpenPrice();
            // 指定货币对 指定MAGIC下的 所有未平仓卖单中 距当前最近的卖单的下单量(交易手数)
            SLASTLOTS = OrderLots();
         }
      }
   }
}

// 本函数用于下1个卖单
void placeSellOrder() {
   // 将下单量的数值转换为指定精度
   orderVolume = NormalizeDouble(orderVolume, 2);
   
   // 限制下单量的数值必须大于系统默认该货币对的最小下单量
   if (orderVolume < MarketInfo(currencyPair, MODE_MINLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MINLOT);
   }
   
   // 限制下单量的数值不得大于预设的最大下单量
   if (orderVolume > maxOrderVolume) {
      orderVolume = maxOrderVolume;
   }
   
   // 限制下单量的数值必须小于系统默认该货币对的最大下单量
   if (orderVolume > MarketInfo(currencyPair, MODE_MAXLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MAXLOT);
   }
   
   // 计算订单的止盈价格
   if (stopProfitPoint == 0) {
      stopProfitPrice = 0;
   }
   
   if (stopProfitPoint > 0) {
      // Tips: 卖单是做空 所以止盈价格为 `卖出价 - 距离`
      // Tips: 同理 止损价格为: `卖出价 + 距离`
      stopProfitPrice = MarketInfo(currencyPair, MODE_BID) - (stopProfitPoint * MarketInfo(currencyPair, MODE_POINT));
   }
   
   // 计算订单的止损价格
   if (stopLossPoint == 0) {
      stopLossPrice = 0;
   }
   
   if (stopLossPoint > 0) {
      stopLossPrice = MarketInfo(currencyPair, MODE_BID) + (stopProfitPoint * MarketInfo(currencyPair, MODE_POINT));
   }
   
   // 完成下卖单动作
   ticket = OrderSend(currencyPair, OP_SELL, orderVolume, MarketInfo(currencyPair, MODE_BID), slippage, stopLossPrice, stopProfitPrice, "下卖单", MAGIC, 0, YellowGreen);
   
   if (!alertFlag) {
      return;
   }
   
   if (ticket < 0) {
      Alert("下卖单失败!", GetLastError());
      return;
   }
   
   Alert("下卖单成功!");
}

// 本函数用于关闭卖单
void closeSellOrder() {
      // 关闭卖单时的买价
   double orderAsk;
   
   // 被选中的订单的交易手数
   double orderLot;
   
   // 被选中的订单的类型 (就是使用OrderSend()函数创建订单时的第2个参数)
   int orderType;
   
   // 被选中的订单的编号
   int orderTicket = 0;
   
   // 用于遍历订单的索引号
   int orderIndex;
   
   // 标识订单关闭是否成功的标记位
   bool closeResult = false;
   
   for( orderIndex = OrdersTotal() - 1; orderIndex >= 0; orderIndex-- ) {
      bool selectResult = OrderSelect(orderIndex, SELECT_BY_POS);
      if (!selectResult) {
         continue;
      }
      
      if (OrdersTotal() <= 0) {
         continue;
      }
      
      if (OrderSymbol() != currencyPair) {
         continue;
      }
      
      if (OrderMagicNumber() != MAGIC) {
         continue;
      }
      
      // 获取订单买价
      orderAsk = MarketInfo(currencyPair, MODE_ASK);
      
      // 获取订单编号
      orderTicket = OrderTicket();
      
      // 获取订单交易手数
      orderLot = OrderLots();
      
      // 获取订单类型
      orderType = OrderType();
      
      // 若订单为卖单 则将该订单关闭(即: 买入平仓)
      if(orderType == OP_SELL) {
         closeResult = OrderClose(orderTicket, orderLot, orderAsk, slippage, Red);
      }
      
      if (alertFlag) {
         Alert("关闭卖单结果为: ", closeResult);
      }
      
      break;
   }
}
```