# 3. 网格策略源码

```mq4
//+------------------------------------------------------------------+
//|                                                         网格策略.mq4 |
//|                                  Copyright 2025, MetaQuotes Ltd. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, MetaQuotes Ltd."
#property link      "https://www.mql5.com"
#property version   "1.00"
#property strict

// 金叉
bool goldenCross = false;

// 死叉
bool deathCross = false;

// 上一次下单的时间
datetime lastPlaceOrderTime;

// currencyPair 货币对
string currencyPair;

// orderVolume 下单量
double orderVolume;

// maxOrderVolume 最大下单量
double maxOrderVolume = 100;

// stopProfitPoint 止盈点数
// stopProfitPrice 止盈价格
// baseStopProfitPrice 以市价下买单时的止盈价格
double stopProfitPoint, stopProfitPrice, baseStopProfitPrice;

// stopLossPoint 止损点数
// stopLossPrice 止损价格
// baseStopLossPrice 以市价下买单时的止损价格
double stopLossPoint, stopLossPrice, baseStopLossPrice;

// MAGIC 魔术号,和EA是1对1关系.本质是一个用户自定义的订单标识.用于在同一个账户中,标识不同EA下的订单
int MAGIC = 111;

// ticket 表示订单的唯一标识符(ID)
int ticket;

// slippage 滑点 即: 下单时预期的成交价格 与 最终实际成交价格 之间的差值
// 滑点是有正负的 
// 正滑点表示实际成交价格比我预期的好(例如我期望1.1000价格买入,但实际成交价格为1.0008,即产生了2个正滑点)
// 负滑点表示实际成交价格比我预期的差(例如我期望1.1000价格买入,但实际成交价格为1.1015,即产生了15个负滑点)
int slippage;

// alertFlag 标识是否开启警告的标记位
bool alertFlag = false;

// 指定货币对 指定MAGIC下的 未平仓买单的总数量
int b = 0;

// 指定货币对 指定MAGIC下的 未平仓买单的盈亏总和
double bProfit = 0;

// 指定货币对 指定MAGIC下的 未平仓卖单的总数量
int s = 0;

// 指定货币对 指定MAGIC下的 未平仓卖单的盈亏总和
double sProfit = 0;

// buyStopPendingOrderLineNumber BUYSTOP线条数量
// 线条: 当设置了1个BUYSTOP挂单时,系统会在设定的挂单价格位置画一条水平线.这条线就是挂单的触发价位.
// 所以这里说的"线条",实际上就是挂单位置.市场价格(K线)一旦触碰或超过这条线,挂单就会被执行,变成一张真实订单.
int buyStopPendingOrderLineNumber;

// buyStopPointDistance BUYSTOP点数距离: 即相邻两个BUYSTOP挂单之间的点数距离
int buyStopPointDistance;

// buyLimitPendingOrderLineNumber BUYLIMIT线条数量
// 线条: 当设置了1个BUYSTOP挂单时,系统会在设定的挂单价格位置画一条水平线.这条线就是挂单的触发价位.
// 所以这里说的"线条",实际上就是挂单位置.市场价格(K线)一旦触碰或超过这条线,挂单就会被执行,变成一张真实订单.
int buyLimitPendingOrderLineNumber;

// buyLimitPointDistance BUYLIMIT点数距离: 即相邻两个BUYLIMIT挂单之间的点数距离
int buyLimitPointDistance;

// sellStopPendingOrderLineNumber SELLSTOP线条数量
// 线条: 当设置了1个BUYSTOP挂单时,系统会在设定的挂单价格位置画一条水平线.这条线就是挂单的触发价位.
// 所以这里说的"线条",实际上就是挂单位置.市场价格(K线)一旦触碰或超过这条线,挂单就会被执行,变成一张真实订单.
int sellStopPendingOrderLineNumber;

// sellStopPointDistance SELLSTOP点数距离: 即相邻两个SELLSTOP挂单之间的点数距离
int sellStopPointDistance;

// sellLimitPendingOrderLineNumber SELLLIMIT线条数量
// 线条: 当设置了1个BUYSTOP挂单时,系统会在设定的挂单价格位置画一条水平线.这条线就是挂单的触发价位.
// 所以这里说的"线条",实际上就是挂单位置.市场价格(K线)一旦触碰或超过这条线,挂单就会被执行,变成一张真实订单.
int sellLimitPendingOrderLineNumber;

// sellLimitPointDistance SELLLIMIT点数距离: 即相邻两个SELLLIMIT挂单之间的点数距离
int sellLimitPointDistance;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- create timer
   EventSetTimer(60);
   
//---
   return(INIT_SUCCEEDED);
  }
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//--- destroy timer
   EventKillTimer();
   
  }
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
//---
   currencyPair = Symbol();
   checkAccount();
   
   goldenCross = false;
   deathCross = false;
   
   checkCross();
   
   if (goldenCross && lastPlaceOrderTime != Time[0] && b == 0) {
      orderVolume = 0.01;
      placeBuyOrder();
      
      buyStopPointDistance = 200;
      buyStopPendingOrderLineNumber = 10;
      placeBuyBUYSTOPOrder();
      
      buyLimitPointDistance = 200;
      buyLimitPendingOrderLineNumber = 10;
      placeBuyBUYLIMITOrder();
      
      lastPlaceOrderTime = Time[0];
   }
   
   if (deathCross && lastPlaceOrderTime != Time[0] && s == 0) {
      orderVolume = 0.01;
      placeSellOrder();
      
      sellStopPointDistance = 200;
      sellStopPendingOrderLineNumber = 10;
      placeSellSELLSTOPOrder();
      
      sellLimitPointDistance = 200;
      sellLimitPendingOrderLineNumber = 10;
      placeSellSELLLIMITOrder();
      
      lastPlaceOrderTime = Time[0];
   }
   
   if (bProfit > 2) {
      closeBuyOrder();
      closeBUYSTOP();
      closeBUYLIMIT();
   }
   
   if (sProfit > 2) {
      closeSellOrder();
      closeSELLSTOP();
      closeSELLLIMIT();
   }
  }
//+------------------------------------------------------------------+
//| Timer function                                                   |
//+------------------------------------------------------------------+
void OnTimer()
  {
//---
   
  }
//+------------------------------------------------------------------+
// 本函数用于检测金叉死叉
void checkCross() {
   double currentShort = iMA(Symbol(), PERIOD_M1, 10, 0, MODE_SMA, PRICE_CLOSE, 0);
   double currentLong = iMA(Symbol(), PERIOD_M1, 20, 0, MODE_SMA, PRICE_CLOSE, 0);
   
   double prevShort = iMA(Symbol(), PERIOD_M1, 10, 0, MODE_SMA, PRICE_CLOSE, 1);
   double prevLong = iMA(Symbol(), PERIOD_M1, 20, 0, MODE_SMA, PRICE_CLOSE, 1);
   
   // 现在的MA10在MA20上方 但之前MA10在MA20下方 则金叉
   if (currentShort > currentLong && prevShort < prevLong) {
      goldenCross = true;
   }
   
   // 现在的MA10在MA20下方 但之前MA10在MA20上方 则死叉
   if (currentShort < currentLong && prevShort > prevLong) {
      deathCross = true;
   }
}

// 本函数用于下1个买单
void placeBuyOrder() {
   // 将下单量的数值转换为指定精度
   orderVolume = NormalizeDouble(orderVolume, 2);
   
   // 限制下单量的数值必须大于系统默认该货币对的最小下单量
   if (orderVolume < MarketInfo(currencyPair, MODE_MINLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MINLOT);
   }
   
   // 限制下单量的数值不得大于预设的最大下单量
   if (orderVolume > maxOrderVolume) {
      orderVolume = maxOrderVolume;
   }
   
   // 限制下单量的数值必须小于系统默认该货币对的最大下单量
   if (orderVolume > MarketInfo(currencyPair, MODE_MAXLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MAXLOT);
   }
   
   // 计算订单的止盈价格
   if (stopProfitPoint == 0) {
      stopProfitPrice = 0;
   }
   
   if (stopProfitPoint > 0) {
      // Tips: 这里之所以使用 `ASK + 距离` 作为买单的止盈价,是因为买单止盈价的定义为: 止盈价 = 开仓价 + 距离
      // Tips: 而一个买单的开仓价是下买单时的ASK价格 所以这里使用 `ASK + 距离`定义止盈价 后续的止损价也是同理的
      // Tips: 很明显,买单是做多,所以价格涨了是止盈,价格跌了是止损
      stopProfitPrice = (MarketInfo(currencyPair, MODE_ASK)) + (stopProfitPoint * MarketInfo(currencyPair, MODE_POINT));
   }
   
   // 计算订单的止损价格
   if (stopLossPoint == 0) {
      stopLossPrice = 0;
   }
   
   if (stopLossPoint > 0) {
      // Tips: 买单止损价 = ASK - 距离
      stopLossPrice = (MarketInfo(currencyPair, MODE_ASK)) - (stopLossPoint * MarketInfo(currencyPair, MODE_POINT));
   }
   
   // 完成下买单动作
   // Violet: 颜色
   ticket = OrderSend(currencyPair, OP_BUY, orderVolume, MarketInfo(currencyPair, MODE_ASK), slippage, stopLossPrice, stopProfitPrice, "下买单", MAGIC, 0, Violet);
   
   if (!alertFlag) {
      return;
   }
   
   if (ticket < 0) {
      Alert("下买单失败!", GetLastError());
      return;
   }
   
   Alert("下买单成功!");
}

// 本函数用于下1个卖单
void placeSellOrder() {
   // 将下单量的数值转换为指定精度
   orderVolume = NormalizeDouble(orderVolume, 2);
   
   // 限制下单量的数值必须大于系统默认该货币对的最小下单量
   if (orderVolume < MarketInfo(currencyPair, MODE_MINLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MINLOT);
   }
   
   // 限制下单量的数值不得大于预设的最大下单量
   if (orderVolume > maxOrderVolume) {
      orderVolume = maxOrderVolume;
   }
   
   // 限制下单量的数值必须小于系统默认该货币对的最大下单量
   if (orderVolume > MarketInfo(currencyPair, MODE_MAXLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MAXLOT);
   }
   
   // 计算订单的止盈价格
   if (stopProfitPoint == 0) {
      stopProfitPrice = 0;
   }
   
   if (stopProfitPoint > 0) {
      // Tips: 卖单是做空 所以止盈价格为 `卖出价 - 距离`
      // Tips: 同理 止损价格为: `卖出价 + 距离`
      stopProfitPrice = MarketInfo(currencyPair, MODE_BID) - (stopProfitPoint * MarketInfo(currencyPair, MODE_POINT));
   }
   
   // 计算订单的止损价格
   if (stopLossPoint == 0) {
      stopLossPrice = 0;
   }
   
   if (stopLossPoint > 0) {
      stopLossPrice = MarketInfo(currencyPair, MODE_BID) + (stopProfitPoint * MarketInfo(currencyPair, MODE_POINT));
   }
   
   // 完成下卖单动作
   ticket = OrderSend(currencyPair, OP_SELL, orderVolume, MarketInfo(currencyPair, MODE_BID), slippage, stopLossPrice, stopProfitPrice, "下卖单", MAGIC, 0, YellowGreen);
   
   if (!alertFlag) {
      return;
   }
   
   if (ticket < 0) {
      Alert("下卖单失败!", GetLastError());
      return;
   }
   
   Alert("下卖单成功!");
}

// 本函数用于关闭买单
void closeBuyOrder() {
   // 关闭买单时的卖价
   double orderBid;
   
   // 被选中的订单的交易手数
   double orderLot;
   
   // 被选中的订单的类型 (就是使用OrderSend()函数创建订单时的第2个参数)
   int orderType;
   
   // 被选中的订单的编号
   int orderTicket = 0;
   
   // 用于遍历订单的索引号
   int orderIndex;
   
   // 标识订单关闭是否成功的标记位
   bool closeResult = false;
   
   // 遍历所有订单
   for( orderIndex = OrdersTotal() - 1; orderIndex >= 0; orderIndex-- ) {
      // OrderSelect()函数用于选定1个订单 选定后可以使用OrderTicket()/OrderType()/OrderLots()等函数
      // 读取这个被选定的订单的属性
      // SELECT_BY_POS: 表示按位置选择
      bool selectResult = OrderSelect(orderIndex, SELECT_BY_POS);
      if (!selectResult) {
         continue;
      }
      
      // 意义不明
      if (OrdersTotal() <= 0) {
         continue;
      }
      
      // 被选定的订单的外汇品种不是当前EA中记录的货币对
      // 则证明该订单不是当前EA要操作的订单
      if (OrderSymbol() != currencyPair) {
         continue;
      }
      
      // 被选定的订单的魔术号不是当前EA中记录的魔术号
      // 则证明该订单并非由当前EA创建 不应该由当前EA操作
      // (目前没有其他EA 所以这个逻辑是正确的 等到自己编写EA时 可能会出现当前EA要关闭的订单是由其他EA创建的情况)
      if (OrderMagicNumber() != MAGIC) {
         continue;
      }
      
      // 获取订单卖价
      orderBid = MarketInfo(currencyPair, MODE_BID);
      
      // 获取订单编号
      orderTicket = OrderTicket();
      
      // 获取订单交易手数
      orderLot = OrderLots();
      
      // 获取订单类型
      orderType = OrderType();
      
      // 若订单为买单 则将该订单关闭(即: 卖出平仓)
      if(orderType == OP_BUY) {
         closeResult = OrderClose(orderTicket, orderLot, orderBid, slippage, Yellow);
      }
      
      if (alertFlag) {
         Alert("关闭买单结果为: ", closeResult);
      }
   }
}

// 本函数用于关闭卖单
void closeSellOrder() {
      // 关闭卖单时的买价
   double orderAsk;
   
   // 被选中的订单的交易手数
   double orderLot;
   
   // 被选中的订单的类型 (就是使用OrderSend()函数创建订单时的第2个参数)
   int orderType;
   
   // 被选中的订单的编号
   int orderTicket = 0;
   
   // 用于遍历订单的索引号
   int orderIndex;
   
   // 标识订单关闭是否成功的标记位
   bool closeResult = false;
   
   for( orderIndex = OrdersTotal() - 1; orderIndex >= 0; orderIndex-- ) {
      bool selectResult = OrderSelect(orderIndex, SELECT_BY_POS);
      if (!selectResult) {
         continue;
      }
      
      if (OrdersTotal() <= 0) {
         continue;
      }
      
      if (OrderSymbol() != currencyPair) {
         continue;
      }
      
      if (OrderMagicNumber() != MAGIC) {
         continue;
      }
      
      // 获取订单买价
      orderAsk = MarketInfo(currencyPair, MODE_ASK);
      
      // 获取订单编号
      orderTicket = OrderTicket();
      
      // 获取订单交易手数
      orderLot = OrderLots();
      
      // 获取订单类型
      orderType = OrderType();
      
      // 若订单为卖单 则将该订单关闭(即: 买入平仓)
      if(orderType == OP_SELL) {
         closeResult = OrderClose(orderTicket, orderLot, orderAsk, slippage, Red);
      }
      
      if (alertFlag) {
         Alert("关闭卖单结果为: ", closeResult);
      }
   }
}

// 本函数用于检查账户的各种情况
void checkAccount() {
   for (int cnt = 0; cnt < OrdersTotal(); cnt++) {
      bool selectResult = OrderSelect(cnt, SELECT_BY_POS, MODE_TRADES);
      if (!selectResult) {
         continue;
      }
      
      if (OrderSymbol() == currencyPair && OrderMagicNumber() == MAGIC) {
         if (OrderType() == OP_SELL) {
            // 指定货币对 指定MAGIC下的 未平仓卖单的总数量
            s++;
            // 指定货币对 指定MAGIC下的 未平仓卖单的盈亏总和
            sProfit += OrderProfit() + OrderCommission() + OrderSwap();
         }
      
         if (OrderType() == OP_BUY) {
            // 指定货币对 指定MAGIC下的 未平仓买单的总数量
            b++;
            // 指定货币对 指定MAGIC下的 未平仓买单的盈亏总和
            bProfit += OrderProfit() + OrderCommission() + OrderSwap();
         }
      }
   }
}

// 本函数用于根据全局变量buyStopPendingOrderLineNumber的值
// 挂一组BUYSTOP单
// BUYSTOP单: 用于追涨的订单.BUYSTOP单的成交价格都是高于挂单时的市场价格的
// 按照定义上来讲 多个连续的BUYSTOP单 只要定义的成交价是递增的(第N个BUYSTOP单成交价 = 第N-1个BUYSTOP单成交价 + 点数距离)即可
void placeBuyBUYSTOPOrder() {
   // 将下单量的数值转换为指定精度
   orderVolume = NormalizeDouble(orderVolume, 2);
   
   // 限制下单量的数值必须大于系统默认该货币对的最小下单量
   if (orderVolume < MarketInfo(currencyPair, MODE_MINLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MINLOT);
   }
   
   // 限制下单量的数值不得大于预设的最大下单量
   if (orderVolume > maxOrderVolume) {
      orderVolume = maxOrderVolume;
   }
   
   // 限制下单量的数值必须小于系统默认该货币对的最大下单量
   if (orderVolume > MarketInfo(currencyPair, MODE_MAXLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MAXLOT);
   }
   
   // 限制挂单之间的点数距离
   if (buyStopPointDistance <= 2) {
      return;
   }
   
   // 限制要挂的订单数量
   if (buyStopPendingOrderLineNumber <= 0) {
      return;
   }
   
   for(int pendingOrderLineIndex = 1; pendingOrderLineIndex <= buyStopPendingOrderLineNumber; pendingOrderLineIndex++) {
      // 计算挂单的止盈价格
      if (stopProfitPoint == 0) {
         baseStopProfitPrice = 0;
         stopProfitPrice = 0;
      }
      
      if (stopProfitPoint > 0) {
         baseStopProfitPrice = MarketInfo(currencyPair, MODE_ASK) + stopProfitPoint * MarketInfo(currencyPair, MODE_POINT);
         // 第N个BUYSTOP买单的止盈价格为 以市价下买单的止盈价格 + N * 止盈点数
         stopProfitPrice = baseStopProfitPrice + pendingOrderLineIndex * stopProfitPoint * MarketInfo(currencyPair, MODE_POINT);
      }
      
      // 计算挂单的止损价格
      if (stopLossPoint == 0) {
         baseStopLossPrice = 0;
         stopProfitPrice = 0;
      }
      
      if (stopLossPoint > 0) {
         baseStopLossPrice = MarketInfo(currencyPair, MODE_ASK) - stopLossPoint * MarketInfo(currencyPair, MODE_POINT);
         stopLossPrice = baseStopLossPrice + pendingOrderLineIndex * stopLossPoint * MarketInfo(currencyPair, MODE_POINT);
      }
      
      // 第N个BUYSTOP买单的买入价格为 市价 + N * 点数距离
      double placePrice = MarketInfo(currencyPair, MODE_ASK) + pendingOrderLineIndex * buyStopPointDistance * MarketInfo(currencyPair, MODE_POINT);
      
      ticket = OrderSend(currencyPair, OP_BUYSTOP, orderVolume, placePrice, slippage, stopLossPrice, stopProfitPrice, "BUYSTOP", MAGIC, 0, Green);
      
      if (!alertFlag) {
         continue;
      }
      
      if (ticket < 0) {
         Alert("BUYSTOP下买单失败: ", GetLastError());
         continue;
      }
      
      Alert("BUYSTOP下买单成功");
   }
}

// 本函数用于根据全局变量buyLimitPendingOrderLineNumber的值
// 挂一组BUYLIMIT单
// BUYLIMIT单: 以低于现价的价格买入的订单.BUYLIMIT单的成交价格都是低于挂单时的市场价格的
// 按照定义上来讲 多个连续的BUYLIMIT单 只要定义的成交价是递减的(第N个BUYSTOP单成交价 = 第N-1个BUYSTOP单成交价 - 点数距离)即可
void placeBuyBUYLIMITOrder() {
   // 将下单量的数值转换为指定精度
   orderVolume = NormalizeDouble(orderVolume, 2);
   
   // 限制下单量的数值必须大于系统默认该货币对的最小下单量
   if (orderVolume < MarketInfo(currencyPair, MODE_MINLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MINLOT);
   }
   
   // 限制下单量的数值不得大于预设的最大下单量
   if (orderVolume > maxOrderVolume) {
      orderVolume = maxOrderVolume;
   }
   
   // 限制下单量的数值必须小于系统默认该货币对的最大下单量
   if (orderVolume > MarketInfo(currencyPair, MODE_MAXLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MAXLOT);
   }
   
   // 限制挂单之间的点数距离
   if (buyLimitPointDistance <= 2) {
      return;
   }
   
   // 限制要挂的订单数量
   if (buyLimitPendingOrderLineNumber <= 0) {
      return;
   }
   
   for(int pendingOrderLineIndex = 1; pendingOrderLineIndex <= buyLimitPendingOrderLineNumber; pendingOrderLineIndex++) {
      // 计算挂单的止盈价格
      if (stopProfitPoint == 0) {
         baseStopProfitPrice = 0;
         stopProfitPrice = 0;
      }
      
      if (stopProfitPoint > 0) {
         baseStopProfitPrice = MarketInfo(currencyPair, MODE_ASK) + stopProfitPoint * MarketInfo(currencyPair, MODE_POINT);
         // 第N个BUYLIMIT买单的止盈价格为 以市价下买单时的止盈价格 - N * 止盈点数
         stopProfitPrice = baseStopProfitPrice - pendingOrderLineIndex * stopProfitPoint * MarketInfo(currencyPair, MODE_POINT);
      }
      
      // 计算挂单的止损价格
      if (stopLossPoint == 0) {
         baseStopLossPrice = 0;
         stopProfitPrice = 0;
      }
      
      if (stopLossPoint > 0) {
         baseStopLossPrice = MarketInfo(currencyPair, MODE_ASK) - stopLossPoint * MarketInfo(currencyPair, MODE_POINT);
         // 第N个BUYLIMIT买单的止损价格为 以市价下买单时的止损价格 - N * 止盈点数
         stopLossPrice = baseStopLossPrice - pendingOrderLineIndex * stopLossPoint * MarketInfo(currencyPair, MODE_POINT);
      }
      
      // 第N个BUYLIMIT买单的买入价格为 市价 - N * 点数距离
      double placePrice = MarketInfo(currencyPair, MODE_ASK) - pendingOrderLineIndex * buyLimitPointDistance * MarketInfo(currencyPair, MODE_POINT);

      ticket = OrderSend(currencyPair, OP_BUYLIMIT, orderVolume, placePrice, slippage, stopLossPrice, stopProfitPrice, "BUYSTOP", MAGIC, 0, Green);
      
      if (!alertFlag) {
         continue;
      }
      
      if (ticket < 0) {
         Alert("BUYLIMIT下买单失败: ", GetLastError());
         continue;
      }
      
      Alert("BUYLIMIT下买单成功");
   }
}

// 本函数用于根据全局变量sellStopPendingOrderLineNumber的值
// 挂一组SELLSTOP单
// SELLSTOP单: 以低于现价(BID价格)的价格卖出的订单.SELLSTOP单的成交价格都是低于挂单时的市场价格的
// 按照定义上来讲 多个连续的SELLSTOP单 只要定义的成交价是递减的(第N个SELLSTOP单成交价 = 第N-1个BUYSTOP单成交价 - 点数距离)即可
// TODO: 这里书中用的是ASK价格 但是我认为卖单应该用BID价格
void placeSellSELLSTOPOrder() {
   // 将下单量的数值转换为指定精度
   orderVolume = NormalizeDouble(orderVolume, 2);
   
   // 限制下单量的数值必须大于系统默认该货币对的最小下单量
   if (orderVolume < MarketInfo(currencyPair, MODE_MINLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MINLOT);
   }
   
   // 限制下单量的数值不得大于预设的最大下单量
   if (orderVolume > maxOrderVolume) {
      orderVolume = maxOrderVolume;
   }
   
   // 限制下单量的数值必须小于系统默认该货币对的最大下单量
   if (orderVolume > MarketInfo(currencyPair, MODE_MAXLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MAXLOT);
   }
   
   // 限制挂单之间的点数距离
   if (sellStopPointDistance <= 2) {
      return;
   }
   
   // 限制要挂的订单数量
   if (sellStopPendingOrderLineNumber <= 0) {
      return;
   }
   
   for(int pendingOrderLineIndex = 1; pendingOrderLineIndex <= sellStopPendingOrderLineNumber; pendingOrderLineIndex++) {
       // 第N个SELLSTOP卖单的卖出价格为 市价 - N * 点数距离
      double placePrice = MarketInfo(currencyPair, MODE_BID) - pendingOrderLineIndex * sellStopPointDistance * MarketInfo(currencyPair, MODE_POINT);
      
      // 第N个SELLSTOP卖单的止盈价 = 第N个SELLSTOP卖单的卖出价格 - 止盈点数
      stopProfitPrice = placePrice - stopProfitPoint * MarketInfo(currencyPair, MODE_POINT);
      
      // 第N个SELLSTOP卖单的止损价 = 第N个SELLSTOP卖单的卖出价格 + 止损点数
      stopLossPrice = placePrice + stopLossPoint * MarketInfo(currencyPair, MODE_POINT);
      
      ticket = OrderSend(currencyPair, OP_BUYLIMIT, orderVolume, placePrice, slippage, stopLossPrice, stopProfitPrice, "BUYSTOP", MAGIC, 0, Green);
      
      if (!alertFlag) {
         continue;
      }
      
      if (ticket < 0) {
         Alert("SELLSTOP下买单失败: ", GetLastError());
         continue;
      }
      
      Alert("SELLSTOP下买单成功");
   }
}

// 本函数用于根据全局变量sellLimitPendingOrderLineNumber的值
// 挂一组SELLLIMIT单
// SELLLIMIT单: 以高于现价(BID价格)的价格卖出的订单.SELLLIMIT单的成交价格都是高于挂单时的市场价格的
// 按照定义上来讲 多个连续的SELLLIMIT单 只要定义的成交价是递增的(第N个SELLSTOP单成交价 = 第N-1个BUYSTOP单成交价 + 点数距离)即可
// TODO: 这里书中用的是ASK价格 但是我认为卖单应该用BID价格
void placeSellSELLLIMITOrder() {
   // 将下单量的数值转换为指定精度
   orderVolume = NormalizeDouble(orderVolume, 2);
   
   // 限制下单量的数值必须大于系统默认该货币对的最小下单量
   if (orderVolume < MarketInfo(currencyPair, MODE_MINLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MINLOT);
   }
   
   // 限制下单量的数值不得大于预设的最大下单量
   if (orderVolume > maxOrderVolume) {
      orderVolume = maxOrderVolume;
   }
   
   // 限制下单量的数值必须小于系统默认该货币对的最大下单量
   if (orderVolume > MarketInfo(currencyPair, MODE_MAXLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MAXLOT);
   }
   
   // 限制挂单之间的点数距离
   if (sellLimitPointDistance <= 2) {
      return;
   }
   
   // 限制要挂的订单数量
   if (sellLimitPendingOrderLineNumber <= 0) {
      return;
   }
   
   for(int pendingOrderLineIndex = 1; pendingOrderLineIndex <= sellLimitPendingOrderLineNumber; pendingOrderLineIndex++) {
       // 第N个SELLLIMIT卖单的卖出价格为 市价 + N * 点数距离
      double placePrice = MarketInfo(currencyPair, MODE_BID) + pendingOrderLineIndex * sellLimitPointDistance * MarketInfo(currencyPair, MODE_POINT);
      
      // 第N个SELLLIMIT卖单的止盈价 = 第N个SELLLIMIT卖单的卖出价格 - 止盈点数
      stopProfitPrice = placePrice - stopProfitPoint * MarketInfo(currencyPair, MODE_POINT);
      
      // 第N个SELLLIMIT卖单的止损价 = 第N个SELLLIMIT卖单的卖出价格 + 止损点数
      stopLossPrice = placePrice + stopLossPoint * MarketInfo(currencyPair, MODE_POINT);
      
      ticket = OrderSend(currencyPair, OP_SELLLIMIT, orderVolume, placePrice, slippage, stopLossPrice, stopProfitPrice, "BUYSTOP", MAGIC, 0, Green);
      
      if (!alertFlag) {
         continue;
      }
      
      if (ticket < 0) {
         Alert("SELLLIMIT下买单失败: ", GetLastError());
         continue;
      }
      
      Alert("SELLLIMIT下买单成功");
   }
}

// 本函数用于关闭BUYLIMIT挂单
void closeBUYLIMIT() {  
   // 订单类型
   int orderType;
   
   // 用于遍历订单的索引
   int orderIndex;
   
   // 用于标识关闭挂单是否成功的标量
   bool closeResult = false;
   
   for (orderIndex = OrdersTotal() - 1; orderIndex >= 0; orderIndex--) {
      bool selectResult = OrderSelect(orderIndex, SELECT_BY_POS);
      if (!selectResult) {
         continue;
      }
      
      if (OrderSymbol() != currencyPair) {
         continue;
      }
      
      if (OrderMagicNumber() != MAGIC) {
         continue;
      }
      
      orderType = OrderType();
      
      if (orderType != OP_BUYLIMIT) {
         continue;
      }
      
      ticket = OrderTicket();
      closeResult = OrderDelete(ticket);
      
      if(!alertFlag) {
         continue;
      }
      
      if(!closeResult) {
         Alert("删除BUYLIMIT挂单失败: ",GetLastError());
         continue;
      }
      
      Alert("成功删除BUYLIMIT挂单,订单号为: ", ticket);
   }
}

// 本函数用于关闭BUYSTOP挂单
void closeBUYSTOP() {  
   // 订单类型
   int orderType;
   
   // 用于遍历订单的索引
   int orderIndex;
   
   // 用于标识关闭挂单是否成功的标量
   bool closeResult = false;
   
   for (orderIndex = OrdersTotal() - 1; orderIndex >= 0; orderIndex--) {
      bool selectResult = OrderSelect(orderIndex, SELECT_BY_POS);
      if (!selectResult) {
         continue;
      }
      
      if (OrderSymbol() != currencyPair) {
         continue;
      }
      
      if (OrderMagicNumber() != MAGIC) {
         continue;
      }
      
      orderType = OrderType();
      
      if (orderType != OP_BUYSTOP) {
         continue;
      }
      
      ticket = OrderTicket();
      closeResult = OrderDelete(ticket);
      
      if(!alertFlag) {
         continue;
      }
      
      if(closeResult) {
         Alert("成功删除BUYSTOP挂单,订单号为: ", ticket);
         continue;
      }
      
      Alert("删除BUYSTOP挂单失败: ",GetLastError());
   }
}

// 本函数用于关闭SELLLIMIT挂单
void closeSELLLIMIT() {  
   // 订单类型
   int orderType;
   
   // 用于遍历订单的索引
   int orderIndex;
   
   // 用于标识关闭挂单是否成功的标量
   bool closeResult = false;
   
   for (orderIndex = OrdersTotal() - 1; orderIndex >= 0; orderIndex--) {
      bool selectResult = OrderSelect(orderIndex, SELECT_BY_POS);
      if (!selectResult) {
         continue;
      }
      
      if (OrderSymbol() != currencyPair) {
         continue;
      }
      
      if (OrderMagicNumber() != MAGIC) {
         continue;
      }
      
      orderType = OrderType();
      
      if (orderType != OP_SELLLIMIT) {
         continue;
      }
      
      ticket = OrderTicket();
      closeResult = OrderDelete(ticket);
      
      if(!alertFlag) {
         continue;
      }
      
      if(!closeResult) {
         Alert("删除SELLLIMIT挂单失败: ",GetLastError());
         continue;
      }
      
      Alert("成功删除SELLLIMIT挂单,订单号为: ", ticket);
   }
}

// 本函数用于关闭SELLSTOP挂单
void closeSELLSTOP() {
   // 订单类型
   int orderType;
   
   // 用于遍历订单的索引
   int orderIndex;
   
   // 用于标识关闭挂单是否成功的标量
   bool closeResult = false;
   
   for (orderIndex = OrdersTotal() - 1; orderIndex >= 0; orderIndex--) {
      bool selectResult = OrderSelect(orderIndex, SELECT_BY_POS);
      if (!selectResult) {
         continue;
      }
      
      if (OrderSymbol() != currencyPair) {
         continue;
      }
      
      if (OrderMagicNumber() != MAGIC) {
         continue;
      }
      
      orderType = OrderType();
      
      if (orderType != OP_SELLSTOP) {
         continue;
      }
      
      ticket = OrderTicket();
      closeResult = OrderDelete(ticket);
      
      if(!alertFlag) {
         continue;
      }
      
      if(!closeResult) {
         Alert("删除SELLSTOP挂单失败: ",GetLastError());
         continue;
      }
      
      Alert("成功删除SELLSTOP挂单,订单号为: ", ticket);
   }
}
```