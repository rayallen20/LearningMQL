# 2. 一根K线交易一单

在编写网格策略之前,需要先解决重复开单的问题.例如:在均线形成金叉时开多单,如果按照原来的思路应该这样编写代码:

```mq4
//+------------------------------------------------------------------+
//|                                                         网格EA.mq4 |
//|                                  Copyright 2025, MetaQuotes Ltd. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, MetaQuotes Ltd."
#property link      "https://www.mql5.com"
#property version   "1.00"
#property strict

// 金叉
bool goldenCross = false;

// 死叉
bool deathCross = false;

// 上一次下单的时间
datetime lastPlaceOrderTime;

// currencyPair 货币对
string currencyPair;

// orderVolume 下单量
double orderVolume;

// maxOrderVolume 最大下单量
double maxOrderVolume = 100;

// stopLossPoint 止损点数
// stopLossPrice 止损价格
double stopLossPoint, stopLossPrice;

// stopProfitPoint 止盈点数
// stopProfitPrice 止盈价格
double stopProfitPoint, stopProfitPrice;

// MAGIC 魔术号,和EA是1对1关系.本质是一个用户自定义的订单标识.用于在同一个账户中,标识不同EA下的订单
int MAGIC = 111;

// ticket 表示订单的唯一标识符(ID)
int ticket;

// slippage 滑点 即: 下单时预期的成交价格 与 最终实际成交价格 之间的差值
// 滑点是有正负的 
// 正滑点表示实际成交价格比我预期的好(例如我期望1.1000价格买入,但实际成交价格为1.0008,即产生了2个正滑点)
// 负滑点表示实际成交价格比我预期的差(例如我期望1.1000价格买入,但实际成交价格为1.1015,即产生了15个负滑点)
int slippage;

// alertFlag 标识是否开启警告的标记位
bool alertFlag = false;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- create timer
   EventSetTimer(60);
   
//---
   return(INIT_SUCCEEDED);
  }
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//--- destroy timer
   EventKillTimer();
   
  }
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
//---
   currencyPair = Symbol();
   checkCross();
   if (goldenCross == true) {
      orderVolume = 0.01;
      placeBuyOrder();
   }
  }
//+------------------------------------------------------------------+
//| Timer function                                                   |
//+------------------------------------------------------------------+
void OnTimer()
  {
//---
   
  }
//+------------------------------------------------------------------+
// 本函数用于检测金叉死叉
void checkCross() {
   double currentShort = iMA(Symbol(), PERIOD_M1, 10, 0, MODE_SMA, PRICE_CLOSE, 0);
   double currentLong = iMA(Symbol(), PERIOD_M1, 20, 0, MODE_SMA, PRICE_CLOSE, 0);
   
   double prevShort = iMA(Symbol(), PERIOD_M1, 10, 0, MODE_SMA, PRICE_CLOSE, 1);
   double prevLong = iMA(Symbol(), PERIOD_M1, 20, 0, MODE_SMA, PRICE_CLOSE, 1);
   
   // 现在的MA10在MA20上方 但之前MA10在MA20下方 则金叉
   if (currentShort > currentLong && prevShort < prevLong) {
      goldenCross = true;
   }
   
   // 现在的MA10在MA20下方 但之前MA10在MA20上方 则死叉
   if (currentShort < currentLong && prevShort > prevLong) {
      deathCross = true;
   }
}

// 本函数用于下1个买单
void placeBuyOrder() {
   // 将下单量的数值转换为指定精度
   orderVolume = NormalizeDouble(orderVolume, 2);
   
   // 限制下单量的数值必须大于系统默认该货币对的最小下单量
   if (orderVolume < MarketInfo(currencyPair, MODE_MINLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MINLOT);
   }
   
   // 限制下单量的数值不得大于预设的最大下单量
   if (orderVolume > maxOrderVolume) {
      orderVolume = maxOrderVolume;
   }
   
   // 限制下单量的数值必须小于系统默认该货币对的最大下单量
   if (orderVolume > MarketInfo(currencyPair, MODE_MAXLOT)) {
      orderVolume = MarketInfo(currencyPair, MODE_MAXLOT);
   }
   
   // 计算订单的止盈价格
   if (stopProfitPoint == 0) {
      stopProfitPrice = 0;
   }
   
   if (stopProfitPoint > 0) {
      // Tips: 这里之所以使用 `ASK + 距离` 作为买单的止盈价,是因为买单止盈价的定义为: 止盈价 = 开仓价 + 距离
      // Tips: 而一个买单的开仓价是下买单时的ASK价格 所以这里使用 `ASK + 距离`定义止盈价 后续的止损价也是同理的
      // Tips: 很明显,买单是做多,所以价格涨了是止盈,价格跌了是止损
      stopProfitPrice = (MarketInfo(currencyPair, MODE_ASK)) + (stopProfitPoint * MarketInfo(currencyPair, MODE_POINT));
   }
   
   // 计算订单的止损价格
   if (stopLossPoint == 0) {
      stopLossPrice = 0;
   }
   
   if (stopLossPoint > 0) {
      // Tips: 买单止损价 = ASK - 距离
      stopLossPrice = (MarketInfo(currencyPair, MODE_ASK)) - (stopLossPoint * MarketInfo(currencyPair, MODE_POINT));
   }
   
   // 完成下买单动作
   // Violet: 颜色
   ticket = OrderSend(currencyPair, OP_BUY, orderVolume, MarketInfo(currencyPair, MODE_ASK), slippage, stopLossPrice, stopProfitPrice, "下买单", MAGIC, 0, Violet);
   
   if (!alertFlag) {
      return;
   }
   
   if (ticket < 0) {
      Alert("下买单失败!", GetLastError());
      return;
   }
   
   Alert("下买单成功!");
}
```

这里存在问题: 在模拟测试或回测时,会在出现金叉的那根K线处不停地下单(因为代码是写在`OnTick()`函数中的),也就是出现重复开仓的问题,不符合策略的本意.

解决方法: 记录下单时间,若当前K线的时间和上一次下单的时间相同,则不再下单:

```mq4
void OnTick()
  {
//---
   currencyPair = Symbol();
   checkCross();
   if (goldenCross == true && lastPlaceOrderTime != Time[0]) {
      orderVolume = 0.01;
      placeBuyOrder();
      lastPlaceOrderTime = Time[0];
   }
  }
```
